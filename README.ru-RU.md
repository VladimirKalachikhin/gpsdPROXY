# gpsdPROXY daemon [![License: CC BY-SA 4.0](https://img.shields.io/badge/License-CC%20BY--SA%204.0-lightgrey.svg)](https://creativecommons.org/licenses/by-sa/4.0/)
**version 0.5**  

Весьма удобно обращаться к **[gpsd](https://gpsd.io/)** из веб-приложений посредством команды [?POLL;](https://gpsd.gitlab.io/gpsd/gpsd_json.html#_poll) в произвольный момент времени, однако есть проблемы:
  
>**во-первых**, данные AIS недоступны в команде ?POLL;  
>**во-вторых**, данные, отличные от тех, что отдаёт приёмник ГПС, могут не попасть в команду ?POLL;

Причина в том, что **gpsd** собирает данные в течение "эпохи" от одного получения координат приёмником ГПС до другого. Но "эпоха" для данных AIS и приборов гораздо длиннее, и эти данные не попадают в запрос ?POLL;  
С деталями и дискуссией по этому поводу можно ознакомиться по следующим ссылкам (англ.):  
[https://lists.nongnu.org/archive/html/gpsd-users/2020-04/msg00093.html](https://lists.nongnu.org/archive/html/gpsd-users/2020-04/msg00093.html)  
[https://lists.nongnu.org/archive/html/gpsd-users/2021-06/msg00017.html](https://lists.nongnu.org/archive/html/gpsd-users/2021-06/msg00017.html)  

Однако надо заметить, что это довольно странная программа, потому что она, в общем, делает ровно то же самое, что и собственно **gpsd**: собирает данные из потока, агрегирует их и отдаёт структурированные данные по требованию. Разница во времени жизни данных.В **gpsdPROXY** его можно задавать явным образом для каждого типа данных.
Думаю, что такая функциональность должна быть непосредственно в **gpsd**. Но этого нет.  
Зато можно применить **gpsdPROXY** для сбора данных от источников, в которых нет контроля достоверности данных. Например, от VenusOS, где нет совсем никакого контроля, и от SignalK, где есть хотя бы метка времени.
Или просто использовать **gpsdPROXY** как websocket интерфейс к **gpsd**.

## Возможности
Предлагаемый демон собирает данные AIS и всё то, что передаётся **gpsd** в секции TPV и хранит их в течение указанного пользователем времени. Получить данные можно запросом [?POLL;](https://gpsd.gitlab.io/gpsd/gpsd_json.html#_poll) протокола **gpsd**.  
Таким образом, все данные AIS и данные эхолота и анемометра (и ГПС, конечно) становятся доступными в произвольный момент времени.

Дополнительно реализован и синхронная потоковая отдача данных, аналогичная режиму ?WATCH={"enable":true,"json":true} **gpsd**. 

### Источники данных
Основным источником данных для gpsdPROXY является **gpsd**, запущенный на той же или другой машине. При использовании **gpsd** обеспечивается максимальная достоверность данных.  
Однако, можно получать данные и из других источников, таких как:

#### VenusOS
gpsdPROXY может работать под управлением VenusOS по крайней мере начиная с версии v2.80~38, и во всяком случае на Raspberry Pi. Работа в устройствах Victron Energy не проверялась. Однако, gpsdPROXY может получать данные от любого устройства в сети, работающего под управлением VenusOS любой версии.  
Для того, чтобы gpsdPROXY мог получать данные, нужно сделать следующие настройки в VenusOS:  
В веб-консоли или на экране управления устройства открыть пункты меню Settings -> Services -> MQTT on LAN (SSL) и указать "Включить".

##### Ограничения
* в VenusOS нет данных о глубине и нет данных AIS
* данные, представляемые VenusOS не являются достаточно достоверными и должны использоваться с осторожностью

#### Signal K
gpsdPROXY может получать данные от сервиса Signal K, работающего на той же машине, или в локальной сети. gpsdPROXY предпримет попытку самостоятельно найти Signal K посредством zeroconf, или обращаясь на стандартный порт. Но лучше сконфигурировать.

##### Ограничения
На самом деле gpsdPROXY к SignalK должен обращаться только локально. Через сеть -- оно странное.

## Использование
```
$ php gpsdPROXY.php
```
К демону можно подключиться через BSD socket или websocket по адресу, указанному в _params.php_.

## Управление
Демон проверяет, не запущен ли он уже, и не запускается вторично.  
Параметры команд **gpsd** не поддерживаются, зато имеются дополнительные параметры:  

* параметр "subscribe":"TPV|AIS" для команд ?POLL и ?WATCH={"enable":true,"json":true}.  
Параметр указывает возвращать только данные TPV или AIS, но не то и другое. Например:  
?POLL={"subscribe":"AIS"} возвращает класс "POLL" с данными "ais":[], вместо "tpv":[].
* параметр "minPeriod":"", в сек. для команды WATCH={"enable":true,"json":true}. Нормально данные отсылаются так часто, как они приходят от **gpsd**. Указание этого параметра заставляет демон отсылать данные не чаще указанного количества секунд. Например, команда:  
WATCH={"enable":true,"json":true,"minPeriod":"2"} посылает данные каждые две секунды, или реже, по мере получения данных.


## Настройка
См. файл _params.php_

## Результат
Демон возвращает данные, как описано в документации к **gpsd**, за исключением:  

* ответ DEVICES на команду WATCH содержит только одно устройство -- сам демон. Как следствие -- не надо объединять сходные данные от разных устройств: это уже делает демон.
* массив _sky_ в объекте POLL пуст
* объект AIS отсутствует в ответе команды WATCH
* в объект POLL и ответ команды WATCH добавлен массив _ais_  с ключами mmsi и данными в формате, описанном в [AIS DUMP FORMATS](https://gpsd.gitlab.io/gpsd/gpsd_json.html#_ais_dump_formats), за исключением:

>* скорость в м/сек
>* координаты в десятичных градусах
>* углы в градусах
>* осадка в метрах
>* длина в метрах
>* ширина в метрах
>* поле 'second' отсутствует, но есть поле 'timestamp' с временем unix



